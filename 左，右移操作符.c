//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>

//右移操作符 >>
//移的是二进制位
//16的二进制是000000000000000000010000，从右边往左边依次0乘2的0次方，0乘2的一次方....到1就是1乘2的4次方，因为整形是32个比特位，所以前面得补0
// 往右移动一位000000000000000000001000，结果是8,右边丢弃，左边补原符合位，
//右移操作符分为：
//1.算术右移 ――>右边丢弃，左边补原符合位，注意：二进制左边第一位为符号位，0为正除，1为负数
//2.逻辑右移 ――>右边丢弃，左边补0
//int main()
//{
//	int a = 16;
//    int b = a >> 1;
//	printf("b = %d", b);
//	return 0;
//
//}

int main()
{
	int a = -1;
	//整数的二进制表示有：原码，反码，补码
	//存储到内存的是补码
	//10000000000000000000000000000001 -- 原码  ，左边1表示符号位，右边就表示1
	//11111111111111111111111111111110 -- 反码  ,原码转反码，符号位不变，其它位按位取反
	//11111111111111111111111111111111 -- 补码  ，反码加1就得到补码，最低位加1
	int b = a >> 1;
	printf("b = %d", b);
	return 0;

}

////左移操作符 -- <<
////左边丢弃，右边补0
int main()
{
//	int a = 5;
// 00000000000000000000000000000101,往左移动1位00000000000000000000000000001010，结果等于10,0乘2的0次方+1乘2的1次方+0乘2的2次方+1乘2的3次方

	int b = a << 1;
	printf("b = %d", b);
	return 0;
}


//负数左移，左边丢弃右边补0
// 二进制转换成十进制看的是原码，负数的补码或反码需要转换成原码，负数补码取反再加1也可以得到原码
//11111111111111111111111111111111 -- 补码, 11111111111111111111111111111110,结果为-2，
int main()
{
	int a = -1;
	int b = a << 1;
	printf("b = %d", b);
	return 0;
}

/*
总结：
	原码
	负数的原码与正数的原码一点点区别，在计算机中一串二进制的首位是符号位，如果是0则代表这个数是整数，
	如果是1则说明这个数是负数。
	正数100的二进制是01100100（一个字节8个bit位）首位是0，说明是正数。
	而-100的二进制原码只需要把第一位符号位的0改成1即可，-100的原码是11100100（首位是符号位，不需要计算，计算时只需计算后7位）。

	反码
	负数的反码转换规则是除了符号位全部取反，-100的原码为11100100，转换成补码为10011011（除了符号位全部取反）。

	补码
	负数的补码转换规则就是在反码的基础上加1即可，-100的反码是10011011，加1就变成了-100的补码，即10011100。

	注意事项：
	1.正数的原反补码相同。
	2.负数原反补码不相同，原码取反（除了符号位）再加1就是补码。
	3.二进制转换成十进制看的是原码，负数的补码或者反码需要转换成原码。
	4.负数补码取反再加1也可以得到原码。

	十进制（123） 1*10^2 + 2*10^1 + 3*10^0 = 123
	二进制（10110） 1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 22

	警告：
	对于移位运算符，不要移动负数位，这个是标准未定义的，
	例如：
	int num = 10;
	num >> -1; //error

*/