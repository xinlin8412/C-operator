#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>



/*
* 如何整形提升：
* 整形提升是按照变量的数据类型的符号位来提升的
* 1.负数的整形提升
* char c1 = -1;
* 变量c1的二进制(补码)中只有8个比特位：11111111
* 因为char 为有符号的 char
* 所以整形提升的时候，高位补充符号位，即为1
* 提升之后的结果是：11111111111111111111111111111111
* 
* 2.正数的整形提升
* char c2 = 1;
* 变量c2的二进制(补码)中只有8个比特位：00000001
* 因为char 为有符号的 char
* 所以整形提升的时候，高位补充符号位，即为0
* 提升之后的结果是：00000000000000000000000000000001
*/
int main()
{
	char a = 3;
	//整形放进char类型里面，把3的二进制放进去，但是因为char为1个字节，只能存储8位，所有这里会截断，只取8位，取最低位
	//00000000000000000000000000000011 //3的二进制位
	//00000011 截断后存储进char a 
	char b = 127;
	//00000000000000000000000001111111 -->127的二进制位
	//01111111  截断后存储进char b

	/*
	a和b相加
	00000011 -a
	01111111 -b
	整形提升高位补充符号位
	00000000000000000000000000000011 ->a
	00000000000000000000000001111111 ->b
	00000000000000000000000010000010 ->结果。直接相加，逢二进一
	结果赋值给c,因为c是char类型，所有得截断，只留低位8个字节，
	结果：10000010 -->c
	printf("%d", c); “%d”打印整形，又得整形提升
	整形提升，高位补充符号位，此时得到的是补码：
	11111111111111111111111110000010 ->补码
	11111111111111111111111110000001 ->反码，补码-1得到反码
	10000000000000000000000001111110 ->原码，反码转原码，符号位不变，其他位按位取反，十进制是-126
	*/

	char c = a + b;
	printf("%d", c);
	return 0;
}




/*
* 隐式类型转换：
* C的整形算术运算总是至少以缺省整形类型的精度来进行的。
* 为了获得精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为整形提升。
* 
* 整形提升的意义：
* 表达式的整形运算要在CPU的相应运算器内执行，CPU内整形运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器长度。
* 
* 因此，即使两个char类型相加，在CPU执行时实际上也要先转换为CPU内整形操作数的标准长度。
* 
* 通用CPU(general-purpose CPU)是难以直接实现两个8个比特位字节直接相加运算(虽然机器指令中可能有这种字节相加指令）。
* 所以，表达式中各种长度可能小于int长度的整形值，都必须先转换为int或unsigned int,然后才能送入CPU去执行运算。
*/


//实例1
int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
	{
		printf("a");
	}
	if (b == 0xb600)
	{
		printf("b");
	}
	if (c == 0xb6000000)
	{
		printf("c");
	}
	return 0;
}
/*
* 会打印c，因为里面本来存储的就是0xb6000000，而char a = 0xb6;和short b = 0xb600;因为比较也算运算，所以a,b都需要整形提升，只有c不会整形提升
*/



//实例2
int main()
{
	char c = 1;
	printf("%d\n", sizeof(c));  //1  //sizeof(c)就是一个字节
	printf("%d\n", sizeof(+c));  //4
	printf("%d\n", sizeof(-c));  //4
	printf("%d\n", sizeof(!c));  //1  ！它不是运算符 只返回两个值true,false.
	//c只要参与表达式运算，就会发生整形提升，表达式+c,就会发生提升，所以sizeof(+c)是4个字节。
	
	return 0;
}